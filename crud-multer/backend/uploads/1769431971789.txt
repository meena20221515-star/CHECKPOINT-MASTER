Got it üëç
You‚Äôre asking **what type of ordering this is called**, because you want:     {
  "name": "checkpoint-master-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.7",
    "@mui/lab": "^7.0.1-beta.21",
    "@mui/material": "^7.3.7",
    "@mui/x-data-grid": "^8.24.0",
    "@mui/x-date-pickers": "^8.25.0",
    "axios": "^1.6.8",
    "date-fns": "^4.1.0",
    "react": "^18.2.0",
    "react-datepicker": "^9.1.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0",
    "web-vitals": "^5.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "devDependencies": {
    "react-scripts": "5.0.1"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
                        

* First stored data stays first
* New data always goes **below** the existing rows
* Order should be **1, 2, 3, 4 ‚Ä¶**
* **Never reverse** like `4,3,2,1`

### ‚úÖ The correct type is:

### **Insertion Order (FIFO)**

or more commonly in tables:

### **Ascending Order by Auto-Increment ID**

---

### How it works conceptually

* Each record gets an **auto-increment ID**
* Table is displayed as:

```
ORDER BY id ASC
```

So your data will always show like:

| ID | Name   |
| -- | ------ |
| 1  | Meena  |
| 2  | Kaviya |
| 3  | Exz    |
| 4  | Abc    |

‚úÖ **Never**:

```
4 Exz
3 Abc
2 Kaviya
1 Meena
```

---

### If this is a database table

Use **Auto Increment / Identity column**

**SQL example:**

```sql
SELECT * FROM checkpoints
ORDER BY id ASC;
```

---

### If this is frontend only (React / JS)

Just **append**, don‚Äôt prepend:

```js
setList(prev => [...prev, newItem]);
```

‚ùå Don‚Äôt do:

```js
[newItem, ...prev] // this causes 4321
```

---

### Short answer (what you can say):

> **Type: Insertion Order / FIFO / Ascending Order by Auto Increment ID**

If you want, tell me:

* Backend (MySQL / PostgreSQL / MongoDB?)
* Or frontend (React / Angular / plain JS?)

I‚Äôll give you the **exact fix code** üëå
--------------------------------------------------

app.js
import React, { useState, useEffect } from 'react';
import {
    Container,
    Paper,
    Typography,
    Box,
    Alert,
    Snackbar,
    LinearProgress,
    Divider,
    Grid,
    Chip
} from '@mui/material';
import CheckpointForm from './components/CheckpointForm';
import CheckpointTable from './components/CheckpointTable';
import CheckpointDialog from './components/CheckpointDialog';
import axios from 'axios';

function App() {
    const [checkpoints, setCheckpoints] = useState([]);
    const [message, setMessage] = useState({ type: '', text: '' });
    const [openDialog, setOpenDialog] = useState(false);
    const [selectedCheckpoint, setSelectedCheckpoint] = useState(null);
    const [dialogMode, setDialogMode] = useState('view');
    const [loading, setLoading] = useState(true);

    // Fetch checkpoints from API
    const fetchCheckpoints = async () => {
        setLoading(true);
        try {
            const res = await axios.get('http://localhost:5000/api/checkpoints');
            // Sort by creation date (oldest first) to maintain 1,2,3,4 order
            const sortedData = res.data.sort((a, b) => 
                new Date(a.createdAt || a.date) - new Date(b.createdAt || b.date)
            );
            setCheckpoints(sortedData);
        } catch (err) {
            console.error('Error fetching checkpoints:', err);
            setCheckpoints([]);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchCheckpoints();
    }, []);

    const showMessage = (type, text) => {
        setMessage({ type, text });
        setTimeout(() => setMessage({ type: '', text: '' }), 3000);
    };

    const handleCheckpointSubmit = async (newCheckpoint) => {
        try {
            // Send to backend
            const response = await axios.post('http://localhost:5000/api/checkpoints', newCheckpoint);
            
            // Add to local state (append at the end for 1,2,3,4 order)
            setCheckpoints([...checkpoints, response.data]);
            showMessage('success', 'Checkpoint saved successfully!');
            fetchCheckpoints(); // Refresh list
        } catch (error) {
            showMessage('error', 'Failed to save checkpoint');
        }
    };

    const handleDelete = async (id) => {
        if (!window.confirm('Are you sure you want to delete this checkpoint?')) {
            return;
        }
        
        try {
            await axios.delete(`http://localhost:5000/api/checkpoints/${id}`);
            setCheckpoints(checkpoints.filter(cp => cp._id !== id));
            showMessage('success', 'Checkpoint deleted successfully!');
        } catch (err) {
            showMessage('error', 'Failed to delete checkpoint');
        }
    };

    const handleView = (id) => {
        const cp = checkpoints.find(cp => cp._id === id);
        if (cp) {
            setSelectedCheckpoint(cp);
            setDialogMode('view');
            setOpenDialog(true);
        }
    };

    const handleEdit = (id) => {
        const cp = checkpoints.find(cp => cp._id === id);
        if (cp) {
            setSelectedCheckpoint(cp);
            setDialogMode('edit');
            setOpenDialog(true);
        }
    };

    const handleDialogClose = () => {
        setOpenDialog(false);
        setSelectedCheckpoint(null);
    };

    const handleUpdate = async (updatedCheckpoint) => {
        try {
            await axios.put(`http://localhost:5000/api/checkpoints/${updatedCheckpoint._id}`, updatedCheckpoint);
            
            setCheckpoints(checkpoints.map(cp => 
                cp._id === updatedCheckpoint._id ? updatedCheckpoint : cp
            ));
            
            setOpenDialog(false);
            showMessage('success', 'Checkpoint updated successfully!');
        } catch (error) {
            showMessage('error', 'Failed to update checkpoint');
        }
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Grid container alignItems="center" justifyContent="space-between" sx={{ mb: 4 }}>
                <Grid item>
                    <Typography variant="h4" sx={{ fontWeight: 'bold', color: '#333' }}>
                        üìã Checkpoint Master
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        Manage your checkpoints in sequential order
                    </Typography>
                </Grid>
                <Grid item>
                    <Chip 
                        label={`${checkpoints.length} Checkpoints`} 
                        color="primary" 
                        variant="outlined"
                    />
                </Grid>
            </Grid>

            {message.text && (
                <Snackbar 
                    open={!!message.text} 
                    autoHideDuration={3000}
                    onClose={() => setMessage({ type: '', text: '' })}
                    anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
                >
                    <Alert severity={message.type} sx={{ width: '100%' }}>
                        {message.text}
                    </Alert>
                </Snackbar>
            )}

            <Paper elevation={1} sx={{ p: 3, mb: 4, border: '1px solid #e0e0e0' }}>
                <Typography variant="h6" gutterBottom sx={{ fontWeight: 'bold', mb: 3, color: '#333' }}>
                    Add New Checkpoint
                </Typography>
                <CheckpointForm onSubmit={handleCheckpointSubmit} />
            </Paper>

            <Divider sx={{ my: 4 }} />

            <Box>
                <Typography variant="h6" sx={{ fontWeight: 'bold', color: '#333', mb: 3 }}>
                    Checkpoint List
                </Typography>
                
                {loading ? (
                    <Box sx={{ textAlign: 'center', py: 4 }}>
                        <LinearProgress sx={{ mb: 2 }} />
                        <Typography>Loading checkpoints...</Typography>
                    </Box>
                ) : (
                    <CheckpointTable 
                        checkpoints={checkpoints} 
                        onDelete={handleDelete}
                        onView={handleView}
                        onEdit={handleEdit}
                    />
                )}
            </Box>

            {selectedCheckpoint && (
                <CheckpointDialog
                    open={openDialog}
                    mode={dialogMode}
                    checkpoint={selectedCheckpoint}
                    onClose={handleDialogClose}
                    onUpdate={handleUpdate}
                />
            )}
        </Container>
    );
}

export default App;
------------------------------------
form.js
import React, { useState } from "react";
import {
  TextField,
  Button,
  Box,
  Grid,
  IconButton,
  Typography,
  Chip,
  Paper,
  InputAdornment,
  Tooltip,
  Stack,
  Card,
  CardContent,
  CardActions
} from "@mui/material";
import AddIcon from "@mui/icons-material/Add";
import DeleteIcon from "@mui/icons-material/Delete";
import ClearIcon from "@mui/icons-material/ClearAll";
import AttachmentIcon from "@mui/icons-material/Attachment";
import TaskIcon from "@mui/icons-material/Task";
import EditIcon from "@mui/icons-material/Edit";
import CheckIcon from "@mui/icons-material/Check";
import CancelIcon from "@mui/icons-material/Cancel";
import axios from "axios";

export default function CheckpointForm({ onSubmit, onRefresh }) {
  const [checkpoint, setCheckpoint] = useState("");
  const [date, setDate] = useState("");
  const [todoInput, setTodoInput] = useState("");
  const [todos, setTodos] = useState([]);
  const [editingTodoIndex, setEditingTodoIndex] = useState(-1);
  const [editTodoText, setEditTodoText] = useState("");
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(false);

  const handleAddTodo = () => {
    if (todoInput.trim()) {
      setTodos([...todos, todoInput.trim()]);
      setTodoInput("");
    }
  };

  const handleRemoveTodo = (index) => {
    const updatedTodos = [...todos];
    updatedTodos.splice(index, 1);
    setTodos(updatedTodos);
  };

  const handleEditTodo = (index) => {
    setEditingTodoIndex(index);
    setEditTodoText(todos[index]);
  };

  const handleSaveTodoEdit = () => {
    if (editTodoText.trim() && editingTodoIndex !== -1) {
      const updatedTodos = [...todos];
      updatedTodos[editingTodoIndex] = editTodoText.trim();
      setTodos(updatedTodos);
      setEditingTodoIndex(-1);
      setEditTodoText("");
    }
  };

  const handleCancelTodoEdit = () => {
    setEditingTodoIndex(-1);
    setEditTodoText("");
  };

  const handleFileChange = (e) => {
    const newFiles = Array.from(e.target.files);
    setFiles([...files, ...newFiles]);
  };

  const handleRemoveFile = (index) => {
    const updatedFiles = [...files];
    updatedFiles.splice(index, 1);
    setFiles(updatedFiles);
  };

  const handleClear = () => {
    setCheckpoint("");
    setDate("");
    setTodoInput("");
    setTodos([]);
    setFiles([]);
    setEditingTodoIndex(-1);
    setEditTodoText("");
  };

  const handleSubmit = async () => {
    if (!checkpoint.trim()) {
      alert("Please enter checkpoint name");
      return;
    }
    if (!date) {
      alert("Please select a date");
      return;
    }
    if (todos.length === 0) {
      alert("Please add at least one todo item");
      return;
    }

    setLoading(true);
    try {
      const formData = new FormData();
      formData.append("checkpoint", checkpoint);
      formData.append("date", date);
      formData.append("todos", JSON.stringify(todos));
      files.forEach(file => formData.append("files", file));

      const res = await axios.post(
        "http://localhost:5000/api/checkpoints",
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        }
      );

      onSubmit(res.data);
      handleClear();
      onRefresh();
    } catch (err) {
      console.error("Submit Error:", err);
      alert("Failed to save checkpoint");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box component="form">
      <Grid container spacing={2} alignItems="center">
        {/* Checkpoint Name */}
        <Grid item xs={12} sm={3}>
          <TextField
            label="Checkpoint Name *"
            value={checkpoint}
            onChange={(e) => setCheckpoint(e.target.value)}
            placeholder="Enter name"
            fullWidth
            size="small"
            variant="outlined"
            required
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  üìå
                </InputAdornment>
              ),
            }}
          />
        </Grid>

        {/* Date */}
        <Grid item xs={12} sm={2}>
          <TextField
            type="date"
            label="Date *"
            value={date}
            onChange={(e) => setDate(e.target.value)}
            InputLabelProps={{ shrink: true }}
            fullWidth
            size="small"
            variant="outlined"
            required
          />
        </Grid>

        {/* Todo Input */}
        <Grid item xs={12} sm={3}>
          <TextField
            label="Add Todos *"
            value={todoInput}
            onChange={(e) => setTodoInput(e.target.value)}
            placeholder="Enter todo item"
            fullWidth
            size="small"
            variant="outlined"
            onKeyPress={(e) => e.key === "Enter" && handleAddTodo()}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  ‚úÖ
                </InputAdornment>
              ),
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    size="small"
                    onClick={handleAddTodo}
                    disabled={!todoInput.trim()}
                  >
                    <AddIcon />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        </Grid>

        {/* File Upload */}
        <Grid item xs={12} sm={2}>
          <Button
            component="label"
            variant="outlined"
            startIcon={<AttachmentIcon />}
            fullWidth
            size="small"
            sx={{ height: "40px" }}
          >
            SELECT FILES
            <input
              type="file"
              hidden
              multiple
              onChange={handleFileChange}
            />
          </Button>
          {files.length > 0 && (
            <Typography variant="caption" color="primary" sx={{ ml: 1 }}>
              ({files.length} selected)
            </Typography>
          )}
        </Grid>

        {/* Action Buttons */}
        <Grid item xs={12} sm={2}>
          <Stack direction="row" spacing={1}>
            <Tooltip title="Clear All">
              <Button
                variant="outlined"
                startIcon={<ClearIcon />}
                onClick={handleClear}
                size="small"
                sx={{ height: "40px" }}
              >
                Clear
              </Button>
            </Tooltip>
            <Button
              variant="contained"
              onClick={handleSubmit}
              disabled={loading || !checkpoint || !date || todos.length === 0}
              size="small"
              sx={{ height: "40px" }}
            >
              {loading ? "Saving..." : "Save"}
            </Button>
          </Stack>
        </Grid>
      </Grid>

      {/* Todo Preview Cards */}
      {todos.length > 0 && (
        <Paper variant="outlined" sx={{ mt: 2, p: 2, bgcolor: "#f8f9fa" }}>
          <Typography variant="subtitle1" fontWeight="bold" gutterBottom color="primary">
            üìã Todo Preview ({todos.length})
          </Typography>
          
          {editingTodoIndex !== -1 && (
            <Card variant="outlined" sx={{ mb: 2, bgcolor: "#fff8e1", borderColor: "#ffb74d" }}>
              <CardContent>
                <Typography variant="subtitle1" fontWeight="medium" gutterBottom>
                  ‚úèÔ∏è Edit Todo #{editingTodoIndex + 1}
                </Typography>
                <Stack direction="row" spacing={1} alignItems="center">
                  <TextField
                    value={editTodoText}
                    onChange={(e) => setEditTodoText(e.target.value)}
                    fullWidth
                    size="small"
                    variant="outlined"
                    autoFocus
                    placeholder="Edit todo text..."
                  />
                  <Button
                    variant="contained"
                    size="small"
                    onClick={handleSaveTodoEdit}
                    startIcon={<CheckIcon />}
                    sx={{
                      bgcolor: "success.main",
                      "&:hover": { bgcolor: "success.dark" }
                    }}
                  >
                    Save
                  </Button>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={handleCancelTodoEdit}
                    startIcon={<CancelIcon />}
                    color="inherit"
                  >
                    Cancel
                  </Button>
                </Stack>
              </CardContent>
            </Card>
          )}

          <Grid container spacing={1}>
            {todos.map((todo, index) => (
              <Grid item xs={12} key={index}>
                <Card 
                  variant="outlined" 
                  sx={{ 
                    borderColor: editingTodoIndex === index ? "#ffb74d" : "#e0e0e0",
                    bgcolor: editingTodoIndex === index ? "#fff8e1" : (index % 2 === 0 ? "#f9f9f9" : "white"),
                    '&:hover': {
                      boxShadow: 1,
                      borderColor: editingTodoIndex === index ? "#ffb74d" : "primary.main"
                    }
                  }}
                >
                  <CardContent sx={{ py: 1.5, px: 2 }}>
                    <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
                      <Box sx={{ display: "flex", alignItems: "center", gap: 2, flex: 1 }}>
                        <Chip 
                          label={`${index + 1}`} 
                          color={editingTodoIndex === index ? "warning" : "primary"}
                          sx={{ 
                            fontWeight: "bold", 
                            minWidth: "32px",
                            height: "32px"
                          }}
                        />
                        <Box sx={{ flex: 1 }}>
                          <Typography variant="subtitle1" fontWeight="medium">
                            {todo}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            Added: {new Date().toLocaleDateString()}
                          </Typography>
                        </Box>
                      </Box>

                      {editingTodoIndex !== index && (
                        <CardActions sx={{ p: 0 }}>
                          <Stack direction="row" spacing={0.5}>
                            <Tooltip title="Edit Todo">
                              <IconButton
                                size="small"
                                onClick={() => handleEditTodo(index)}
                                sx={{ 
                                  bgcolor: "#fff8e1",
                                  color: "warning.main",
                                  '&:hover': { 
                                    bgcolor: "#ffecb3",
                                    color: "warning.dark"
                                  }
                                }}
                              >
                                <EditIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>

                            <Tooltip title="Delete Todo">
                              <IconButton
                                size="small"
                                onClick={() => {
                                  if (window.confirm(`Delete "${todo}"?`)) {
                                    handleRemoveTodo(index);
                                  }
                                }}
                                sx={{ 
                                  bgcolor: "#ffebee",
                                  color: "error.main",
                                  '&:hover': { 
                                    bgcolor: "#ffcdd2",
                                    color: "error.dark"
                                  }
                                }}
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </Stack>
                        </CardActions>
                      )}
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>
        </Paper>
      )}
    </Box>
  );
}
----------------------------------------------
server.js
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const path = require("path");
require("dotenv").config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI || "mongodb://localhost:27017/checkpoint-master", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log("‚úÖ MongoDB Connected"))
.catch(err => console.error("‚ùå MongoDB Connection Error:", err));

// Routes
const checkpointRoutes = require("./routes/checkpointRoutes");
app.use("/api/checkpoints", checkpointRoutes);

// Default Route
app.get("/", (req, res) => {
  res.json({ message: "Checkpoint Master API Running" });
});

app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
});
---------------------------------------------------
package.json (backend)

{
  "name": "checkpoint-master-backend",
  "version": "1.0.0",
  "description": "Checkpoint Master backend with Express, MongoDB and Multer",
  "main": "server.js",
  "type": "commonjs",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^4.22.1",
    "mongoose": "^8.21.0",
    "multer": "^1.4.5-lts.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  }
}
------------------------------
routes.js
const express = require("express");
const multer = require("multer");
const {
  createCheckpoint,
  getCheckpoints,
  getCheckpointById,
  updateCheckpoint,
  deleteCheckpoint,
  deleteFile
} = require("../controllers/checkpointController");

const router = express.Router();

// Configure Multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/");
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB limit
});

// Routes
router.post("/", upload.array("files", 10), createCheckpoint);
router.get("/", getCheckpoints);
router.get("/:id", getCheckpointById);
router.put("/:id", upload.array("files", 10), updateCheckpoint);
router.delete("/:id", deleteCheckpoint);
router.delete("/files/:checkpointId/:filename", deleteFile);

module.exports = router;
-------------------------------------------
checkpoint.js

const mongoose = require("mongoose");

const checkpointSchema = new mongoose.Schema({
  checkpoint: {
    type: String,
    required: true,
    trim: true
  },
  date: {
    type: Date,
    required: true
  },
  todos: [{
    type: String,
    required: true
  }],
  files: [{
    type: String
  }],
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model("Checkpoint", checkpointSchema);
------------------------------------------------
dialog

import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  IconButton,
  Typography,
  Box,
  CircularProgress
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import DownloadIcon from "@mui/icons-material/Download";
import PictureAsPdfIcon from "@mui/icons-material/PictureAsPdf";
import ImageIcon from "@mui/icons-material/Image";
import DescriptionIcon from "@mui/icons-material/Description";

export default function FileViewerDialog({ open, onClose, filename }) {
  const [loading, setLoading] = React.useState(true);
  const [fileUrl, setFileUrl] = React.useState("");
  const [fileType, setFileType] = React.useState("");

  React.useEffect(() => {
    if (open && filename) {
      setLoading(true);
      
      // Build file URL
      const url = `http://localhost:5000/uploads/${filename}`;
      setFileUrl(url);
      
      // Detect file type from extension
      const ext = filename.split('.').pop().toLowerCase();
      if (['pdf'].includes(ext)) {
        setFileType('pdf');
      } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(ext)) {
        setFileType('image');
      } else if (['txt', 'csv', 'json', 'js', 'html', 'css'].includes(ext)) {
        setFileType('text');
      } else {
        setFileType('unknown');
      }
      
      setLoading(false);
    }
  }, [open, filename]);

  const getFileIcon = () => {
    switch (fileType) {
      case 'pdf': return <PictureAsPdfIcon color="error" />;
      case 'image': return <ImageIcon color="primary" />;
      default: return <DescriptionIcon color="action" />;
    }
  };

  const handleDownload = () => {
    window.open(fileUrl, '_blank');
  };

  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      maxWidth="lg"
      fullWidth
      PaperProps={{ sx: { height: '90vh' } }}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            {getFileIcon()}
            <Typography variant="h6" noWrap sx={{ maxWidth: '400px' }}>
              {filename}
            </Typography>
          </Box>
          
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <IconButton onClick={handleDownload} title="Download">
              <DownloadIcon />
            </IconButton>
            <IconButton onClick={onClose}>
              <CloseIcon />
            </IconButton>
          </Box>
        </Box>
      </DialogTitle>
      
      <DialogContent dividers sx={{ p: 0, bgcolor: '#f5f5f5' }}>
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '400px' }}>
            <CircularProgress />
          </Box>
        ) : fileType === 'pdf' ? (
          // PDF View
          <Box sx={{ width: '100%', height: '100%' }}>
            <iframe
              src={fileUrl}
              title={filename}
              width="100%"
              height="100%"
              style={{ border: 'none' }}
            />
          </Box>
        ) : fileType === 'image' ? (
          // Image View
          <Box sx={{ 
            display: 'flex', 
            justifyContent: 'center', 
            alignItems: 'center',
            height: '100%',
            p: 2
          }}>
            <img
              src={fileUrl}
              alt={filename}
              style={{ 
                maxWidth: '100%', 
                maxHeight: '100%',
                objectFit: 'contain'
              }}
            />
          </Box>
        ) : fileType === 'text' ? (
          // Text File View
          <Box sx={{ p: 3, bgcolor: 'white', height: '100%', overflow: 'auto' }}>
            <Typography 
              variant="body2" 
              component="pre"
              sx={{ 
                whiteSpace: 'pre-wrap',
                fontFamily: 'monospace',
                fontSize: '0.9rem'
              }}
            >
              Loading text content...
            </Typography>
          </Box>
        ) : (
          // Other Files (Download only)
          <Box sx={{ 
            display: 'flex', 
            flexDirection: 'column',
            justifyContent: 'center', 
            alignItems: 'center',
            height: '300px',
            gap: 2
          }}>
            <DescriptionIcon sx={{ fontSize: 60, color: 'gray' }} />
            <Typography variant="h6" color="text.secondary">
              Preview not available
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Click Download to view this file
            </Typography>
            <Button 
              variant="contained" 
              startIcon={<DownloadIcon />}
              onClick={handleDownload}
            >
              Download File
            </Button>
          </Box>
        )}
      </DialogContent>
      
      <DialogActions sx={{ p: 2, bgcolor: '#f5f5f5' }}>
        <Typography variant="caption" color="text.secondary" sx={{ flex: 1 }}>
          File: {filename}
        </Typography>
        <Button onClick={onClose} variant="outlined">
          Close
        </Button>
        <Button onClick={handleDownload} variant="contained" startIcon={<DownloadIcon />}>
          Download
        </Button>
      </DialogActions>
    </Dialog>
  );
}
---------------------------------------------
index.js

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

const theme = createTheme({
  palette: {
    primary: {
      main: "#1976d2",
      light: "#42a5f5",
      dark: "#1565c0",
    },
    secondary: {
      main: "#9c27b0",
    },
    background: {
      default: "#f5f5f5",
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
  },
  shape: {
    borderRadius: 8,
  },
});

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);
---------------------------------